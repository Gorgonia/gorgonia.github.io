[{"uri":"https://gorgonia.org/fr/getting-started/","title":"Premiers pas","tags":[],"description":"Démarrer rapidement avec Gorgonia","content":" Obtenir Gorgonia Gorgonia est go-gettable et supporte les go-modules. Pour récupérer la bibliothèque ainsi que ses dépendances, il suffit d\u0026rsquo;exécuter:\n$ go get gorgonia.org/gorgonia Premier programme pour faire un calcul simple Créer ce programme simple dans un fichier main.go pour vérifier que tout est correctement installé:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;gorgonia.org/gorgonia\u0026#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // define the expression  x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;x\u0026#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(\u0026#34;y\u0026#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.Fatal(err) } // create a VM to run the program on  machine := gorgonia.NewTapeMachine(g) defer machine.Close() // set initial values then run  gorgonia.Let(x, 2.0) gorgonia.Let(y, 2.5) if err = machine.RunAll(); err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;%v\u0026#34;, z.Value()) } Exécuter le programme devrait afficher le résultat 4.5.\nPour plus d\u0026rsquo;explications sur le fonctionnement, veuillez consulter le tutoriel Hello World.\n"},{"uri":"https://gorgonia.org/fr/about/","title":"Fonctionnement de Gorgonia","tags":[],"description":"Suite d&#39;articles pour expliquer le fonctionnement de Gorgonia","content":" À propos Gorgonia fonctionne en créant un graphe de calcul et en l\u0026rsquo;exécutant. C\u0026rsquo;est en quelque sorte un langage de programmation, mais limité aux fonctions mathématiques sans capacité de branche (pas d\u0026rsquo;instructions conditionnelles if/else ou de boucles). C\u0026rsquo;est le paradigme dominant que l\u0026rsquo;utilisateur doit avoir en tête. Le graphe de calcul est un AST.\nCNTK de Microsoft, avec le BrainScript, représente probablement le meilleur exemple de cette idée que construire et exécuter le graphe sont deux choses distinctes. L\u0026rsquo;utilisateur dois penser différemment la construction du graphe et son exécution.\nCependant que l\u0026rsquo;implémentation utilisée par Gorgonia ne force pas la séparation des choses de manière aussi poussée que Brainscript.\nPour aller plus loin Ce chapitre contient des articles ayant pour but d\u0026rsquo;expliquer comment Gorgonia fonctionne.\nLes articles de cette section focus surla compréhension des choses. Chaque article est auto suffisant et fournit le context nécessaire à la compréhension.\n  "},{"uri":"https://gorgonia.org/fr/tutorials/","title":"Tutoriels","tags":[],"description":"Tutoriels sur quelques cas d&#39;usage","content":" Tutoriels tutoriels pour démarrer sur quelques cas d\u0026rsquo;usage de Gorgonia.\nCes tutoriels:\n sont orientés apprentissage sont une introduction pour les nouveaux venus. sont une leçon  Analogie: apprendre à un enfant à cuisines\nListe des tutoriels disponibles  Régression linéaire multivariée sur le dataset Iris   "},{"uri":"https://gorgonia.org/fr/getting-started/ubiquitous-language/","title":"Language dédié et glossaire","tags":[],"description":"","content":" Cette page contient diverses définitions et un glossaire vous permettant de comprendre Gorgonia et de communiquer avec l\u0026rsquo;équipe (via PR ou issues).\nTenseurs  inner(most) dimension(s) (dimensions intérieures (maximales))- pour une forme donnée, les dimensions intérieures tendent vers la droite. Par exemple, dans une forme (2,3,4), les dimensions intérieures sont (3, 4). La dimension intérieure maximale est 4. outer(most) dimension(s) (dimensions exérieures (maximales))- Pour une forme donnée, les dimensions extérieures tendent vers la gauche. Par exemple, dans une forme (2,3,4), les dimensions extérieures sont (2, 3). La dimension extérieure maximale est 2. vector (vecteur) - pour un tenseur de rang 1; par exemple (2), (3) \u0026hellip; les vecteurs vont s\u0026rsquo;écrire [...] column vector (or colvec) (colonnes de vecteurs) -un tenseur de rang 2 (par exemple une matrice) avec des dimensions intérieures comme 1, par exemple (2, 1), (3, 1)\u0026hellip; row vector (vecteur de ligne) - un tenseur de rang 2 (par exemple une matrice) avec la dimension extérieure 1; par exemple (1, 2), (1, 3)\u0026hellip; matrix (matrice) un tenseur de rang -2, avec des dimensions intérieures et extérieures aléatoires; par exemple (1, 2), (2, 1), (2, 3)\u0026hellip; les matrices vont être notées en écriture intégrale dans ce doc. Ceci inclut les vecteurs colonnes et les vecteurs lignes.  "},{"uri":"https://gorgonia.org/fr/getting-started/contributing-doc/","title":"Commencer à contribuer à la documentation","tags":[],"description":"","content":" Si vous souhaitez commencer à contribuer à la documentation de Gorgonia, cette page et ses points liés peuvent vous aider. Pas besoin d\u0026rsquo;être un développeur ou un rédacteur technique pour avoir un grand impact sur la documentation de Gorgonia et l\u0026rsquo;expérience utilisateur ! Pour les points de cette page, il vous suffit d\u0026rsquo;avoir un compte GitHub et un navigateur internet.\nSi vous cherchez des informations sur comment contribuer aux dépôts de code de Gorgonia, consultez les directives de contribution.\nLes bases de la documentation La documentation de Gorgonia est écrite en Markdown et traitée avec Hugo. Sa source est sur GitHub à ce lien https://github.com/gorgonia/gorgonia.github.io. La plupart de la source de la documentation est située dans /content/.\nVous pouvez signaler les problèmes, modifier le contenu et examiner les modifications des autres, le tout à partir du site web GitHub. Vous pouvez également utiliser l\u0026rsquo;historique intégré et les outils de recherche de GitHub.\nMise en page de la documentation La documentation suit la mise en page décrite dans l\u0026rsquo;article Ce que personne ne vous dit sur la documentation.\nElle est divisée en 4 sections. Chaque section est un sous-répertoire dans le directoire content/ du dépôt.\nLes tutoriels Un tutoriel :\n est orienté sur l\u0026rsquo;apprentissage aide un débutant à commencer est une leçon  Analogie: ça doit être comme apprendre à un enfant à cuisiner\nSources du contenu dans le dépôt : content/tutorials\nLes guides HOW-TO Un guide how-to :\n est orienté sur un objectif montre comment résoudre un problème précis est une série d\u0026rsquo;étapes  Analogie: comme une recette dans un livre de cuisine\nSources du contenu dans le dépôt : content/how-to\nLes explications Une explication :\n est orientée sur la compréhension explique apporte du contexte  Analogie : un article sur l\u0026rsquo;histoire sociale culinaire\nSources du contenu dans le dépôt : content/about\nLes références Un guide de référence :\n est orienté sur l\u0026rsquo;information décrit les mécanismes est précis et complet  Analogie : un article d\u0026rsquo;encyclopédie de référence\nSources du contenu dans le dépôt : content/reference\nPlusieurs langues La source de documentation est disponible en plusieurs langues dans / content /. Chaque page peut être traduite dans n\u0026rsquo;importe quelle langue en ajoutant un code à deux lettres déterminé par la norme ISO 639-1. Un fichier sans suffixe est par défaut en anglais.\nPar exemple, la documentation française d\u0026rsquo;une page s\u0026rsquo;appelle page.fr.md.\nAméliorer la documentation Corriger un contenu existant Vous pouvez améliorer la documentation en corrigeant un bug ou une faute de frappe dans la doc. Pour améliorer le contenu existant, vous déposez une _pull request (PR) _ après avoir créé une _fourche (fork) _. Ces deux termes sont spécifiques à GitHub. Pour les besoins de cette rubrique, vous n\u0026rsquo;avez pas besoin de tout savoir à leur sujet, car vous pouvez tout faire à l\u0026rsquo;aide de votre navigateur Web.\nCréer de nouveaux contenus  Les sources du référentiel sont conservées dans la branche develop. Par conséquent, créez votre nouvelle branche dans develop et la PR doit également pointer vers cette branche.\n Pour créer un nouveau contenu, merci de créer une nouvelle page dans le directoire correspondant au sujet de la doc (voir le paragraphe Mise en page de la documentation)\nSi vous avez hugo localement, vous pouvez créer une nouvelle page avec :\nhugo new content/about/mypage.md sinon, veuillez créer une nouvelle page avec un en-tête qui ressemble à :\n---title:\u0026#34;The title of the page\u0026#34;date:2020-01-31T14:59:03+01:00draft:false--- your content Ensuite, soumettez une PR comme expliqué ci-dessous.\nSoumettre une pull request (PR) Suivez ces étapes pour soumettre une PR afin d\u0026rsquo;améliorer la documentation de Gorgonia.\n Sur la page où vous voyez l\u0026rsquo;issue, cliquez sur l\u0026rsquo;icône \u0026ldquo;modifier cette page\u0026rdquo; en haut à droite. Une nouvelle page GitHub apparaît, avec un texte d\u0026rsquo;aide. Si vous n\u0026rsquo;avez jamais créé de fork du référentiel de documentation Gorgonia, vous êtes invité à le faire. Créez le fork sous votre nom d\u0026rsquo;utilisateur GitHub, plutôt que sous celui d\u0026rsquo;une autre organisation dont vous pouvez être membre. Le fork a généralement une URL type https://github.com/ \u0026lt;username\u0026gt; / website, sauf si vous avez déjà un référentiel avec un nom en conflit.\nLa raison pour laquelle vous êtes invité à créer un fork est que vous n\u0026rsquo;avez pas accès aux droits pour créer une branche directement dans le référentiel Gorgonia définitif.\n L\u0026rsquo;éditeur GitHub Markdown apparaît avec le fichier Markdown source. Faites vos changements. Sous l\u0026rsquo;éditeur, remplissez le formulaire ** Propose file change **. Le premier champ est le résumé de votre message de validation et ne doit pas contenir plus de 50 caractères. Le deuxième champ est facultatif, mais peut inclure plus de détails le cas échéant. Cliquez sur ** Propose file change **. La modification est enregistrée en tant que commit dans une nouvelle branche de votre fork, qui est automatiquement nommée quelque chose comme patch-1.\n  N\u0026rsquo;incluez pas de références à d\u0026rsquo;autres isuues GitHub ou pull requests dans votre message de validation. Vous pouvez les ajouter à la description de la pull request plus tard.\n  L\u0026rsquo;écran suivant résume les modifications que vous avez apportées, en comparant votre nouvelle branche (les cases de sélection head fork et compare) à la base fork et base de la branche actuelle (develop dans le référentiel gorgonia/gorgonia.github.io par défaut). Vous pouvez modifier n\u0026rsquo;importe quelle boîte de sélection, mais ne le faites pas maintenant. Jetez un œil au visualisateur de différences en bas de l\u0026rsquo;écran, et si tout semble correct, cliquez sur Create pull request.  Si vous ne souhaitez pas créer la pull request maintenant, vous pouvez le faire plus tard, en accédant à l\u0026rsquo;URL principale du référentiel du site Web Gorgonia ou le référentiel de votre fork. Le site Web GitHub vous invite à faire une pull request s\u0026rsquo;il détecte que vous avez poussé une nouvelle branche vers votre fork.\n  L\u0026rsquo;écran Open a pull request apparaît. L\u0026rsquo;objet de la pull request est le même que le résumé du commit, mais vous pouvez le modifier si nécessaire. le Le corps est rempli par votre message de validation (si présent) et du texte du modèle. Lisez le texte du modèle et remplissez les détails qu\u0026rsquo;il demande, puis supprimez le texte du modèle en trop. Si vous ajoutez fixes #\u0026lt;000000\u0026gt; ou closes #\u0026lt;000000\u0026gt; à la description, avec #\u0026lt;000000\u0026gt; le numéro de l\u0026rsquo;issue associée, GitHub fermera automatiquement l\u0026rsquo;issue lors de l\u0026rsquo;intégration de la PR. Laissez la case Allow edits from maintainers sélectionnée. Cliquez sur Create pull request.\nFélicitations ! Votre pull request est disponible dans Pull requests.\n  Veuillez limiter vos pull requests à une langue par PR. Par exemple, si vous devez apporter une modification identique au même bout de code dans plusieurs langues, ouvrez une PR distincte pour chaque langue.\n  Attendez une relecture. Si un relecteur vous demande de faire une modification, vous pouvez ouvrir l\u0026rsquo;onglet Files changed et cliquer sur l\u0026rsquo;icône crayon ou n\u0026rsquo;importe quel fichier concerné par la pull request. Quand vous sauvegardez le fichier modifié, un nouveau commit est créé dans la branche de la pull request. Si vous attendez qu\u0026rsquo;un relecteur relise les modifications, relancez-le tous les 7 jours. Vous pouvez aussi accéder à la chaîne #gorgonia sur gopherslack, bon endroit pour demander de l\u0026rsquo;aide sur les relectures de PR.\n Si votre modification est acceptée, un réviseur valide votre pull request et le le changement se fait en direct sur le site Web de Gorgonia quelques minutes plus tard.\n  Ce n\u0026rsquo;est qu\u0026rsquo;une manière de soumettre une pull request. Si vous êtes déjà un utilisateur avancé de GitHub, vous pouvez utiliser une interface graphique locale ou un client Git en ligne de commande au lieu d\u0026rsquo;utiliser l\u0026rsquo;interface utilisateur de GitHub.\n"},{"uri":"https://gorgonia.org/fr/tutorials/iris/","title":"Régression linéaire multivariée sur le dataset Iris","tags":[],"description":"","content":" A propos Nous allons utiliser Gorgonia pour créer un modèle de régression linéaire.\nLe but de ce tutoriel est de prédire l\u0026rsquo;espèce d\u0026rsquo;une fleur en fonction de ses caractéristiques:\n sepal_length // longueur du sépale sepal_width // largeur du sépale petal_length // longueur du pétale petal_width // largeurdu pétale  Les espèces que nous voulons prédire sont:\n setosa virginica versicolor  Le but de ce tutoriel est de programmer Gorgonia pour qu\u0026rsquo;il trouve seul les paramètres qui permettent de déterminer la relation entre les attributs et le spécimen. À la fin, nous écrirons un utilitaire CLI (autonome) dont l\u0026rsquo;interface sera la suivante:\n./iris sepal length: 5 sepal width: 3.5 petal length: 1.4 sepal length: 0.2 It is probably a setosa Ce tutoriel est à vocation académique. Son but est de décrire comment réaliser une régression linéaire multivariée avec Gorgonia; Ainsi, le modèle utilisé n\u0026rsquo;est pas la meilleur réponse à ce problème particulier.\n Représentation Mathématique Nous considérons que l\u0026rsquo;espèce d\u0026rsquo;une Iris est fonction de la longueur et de la largeur de son sépale ainsi que de la longueur et de la largeur de son pétale.\nPar conséquent, soit $y$ une valeur représentant l\u0026rsquo;espèce, l\u0026rsquo;équation que nous essayons de résoudre est:\n$$ y = \\theta_0 + \\theta_1 * sepal\\_length + \\theta_2 * sepal\\_width + \\theta_3 * petal\\_length + \\theta_4 * petal\\_width$$\nConsidérons à présent les vecteurs $x$ et $\\Theta$ suivants:\n$$ x = \\begin{bmatrix} sepal\\_length \u0026amp; sepal\\_width \u0026amp; petal\\_length \u0026amp; petal\\_width \u0026amp; 1\\end{bmatrix}$$\n$$ \\Theta = \\begin{bmatrix} \\theta_4 \\theta_3 \\theta_2 \\theta_1 \\theta_0 \\end{bmatrix} $$\nNous pouvons réécrire l\u0026rsquo;équation:\n$$y = x\\cdot\\Theta$$\nRégression linéaire Pour trouver les bonnes valeurs de $\\Theta$ rendant l\u0026rsquo;équation vraie pour la majorité des Iris, nous allons utiliser une régression linéaire.\nNous allons encoder les données d\u0026rsquo;entrainement (les constats fait sur plusieurs fleurs) dans une matrice $X$. $X$ est composée de 5 colonnes: sepal length, sepal width, petal length, petal width et une colonne contenant 1 pour le biais. Chaque ligne de la matrice représente une fleur.\nNous allons encoder les espèces dans un vecteur colonne $Y$ composé de nombres flottants.\n setosa = 1.0 virginica = 2.0 versicolor = 3.0  Lors de la phase d\u0026rsquo;apprentissage, le coût est exprimé de la manière suivante:\n$cost = \\dfrac{1}{m} \\sum_{i=1}^m(X^{(i)}\\cdot\\Theta-Y^{(i)})^2$\nNous allons utiliser la méthode de descente de gradient pour optimiser le coût et obtenir les valeurs optimales de $\\Theta$.\nIl est possible d\u0026rsquo;avoir les valeurs exactes de $\\Theta$ (celle qui minimisent le coût) en utilisant l\u0026rsquo;équation normale: $$ \\theta = \\left( X^TX \\right)^{-1}X^TY $$ Vous trouverez sur ce gist une implémentation basique de la solution réalisée avec Gonum.\n Génération des données d\u0026rsquo;entrainement avec gota (dataframe) Tout d\u0026rsquo;abord, générons les données d\u0026rsquo;entrainement. Nous utiliserons un dataframe pour nous simplifier la tâche.\nCe howto donne plus d\u0026rsquo;informations sur l\u0026rsquo;utilisation du dataframe\n func getXYMat() (*mat.Dense, *mat.Dense) { f, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) xDF := df.Drop(\u0026#34;species\u0026#34;) toValue := func(s series.Series) series.Series { records := s.Records() floats := make([]float64, len(records)) for i, r := range records { switch r { case \u0026#34;setosa\u0026#34;: floats[i] = 1 case \u0026#34;virginica\u0026#34;: floats[i] = 2 case \u0026#34;versicolor\u0026#34;: floats[i] = 3 default: log.Fatalf(\u0026#34;unknown iris: %v\\n\u0026#34;, r) } } return series.Floats(floats) } yDF := df.Select(\u0026#34;species\u0026#34;).Capply(toValue) numRows, _ := xDF.Dims() xDF = xDF.Mutate(series.New(one(numRows), series.Float, \u0026#34;bias\u0026#34;)) fmt.Println(xDF.Describe()) fmt.Println(yDF.Describe()) return mat.DenseCopyOf(\u0026amp;matrix{xDF}), mat.DenseCopyOf(\u0026amp;matrix{yDF}) } Cette fonction retourne deux matrices que nous pourrons utiliser avec Gorgonia.\nCreation de l\u0026rsquo;ExprGrap L\u0026rsquo;équation $X\\cdot\\Theta$ est encodée en tant qu\u0026rsquo;ExprGraph:\nfunc getXY() (*tensor.Dense, *tensor.Dense) { x, y := getXYMat() xT := tensor.FromMat64(x) yT := tensor.FromMat64(y) // Get rid of the last dimension to create a vector \ts := yT.Shape() yT.Reshape(s[0]) return xT, yT } func main() { xT, yT := getXY() g := gorgonia.NewGraph() x := gorgonia.NodeFromAny(g, xT, gorgonia.WithName(\u0026#34;x\u0026#34;)) y := gorgonia.NodeFromAny(g, yT, gorgonia.WithName(\u0026#34;y\u0026#34;)) theta := gorgonia.NewVector( g, gorgonia.Float64, gorgonia.WithName(\u0026#34;theta\u0026#34;), gorgonia.WithShape(xT.Shape()[1]), gorgonia.WithInit(gorgonia.Uniform(0, 1))) pred := must(gorgonia.Mul(x, theta)) // Saving the value for later use  var predicted gorgonia.Value gorgonia.Read(pred, \u0026amp;predicted) Gorgonia est très optimisé; il fait utilise beaucoup les pointeurs pour optimiser son empreinte mémoire. Par conséquemt, appeler la méthode Value() d\u0026rsquo;un *Node pendant la phase d\u0026rsquo;exécution du graphe, peut produire des résultats incorrects. Pour accéder à la valeur contenue dans un *Node (pendant la phase d\u0026rsquo;apprentissage par exemple), il est nécessaire de garder une référence pointant sur ladite valeur. C\u0026rsquo;est la raison pour laquelle nous utilisons la méthode Read. predicted contient une référence à la valeur résultante de l\u0026rsquo;opération $X\\cdot\\Theta$.\n Préparation du calcul du gradient Nous allons utiliser la fonctionnalité de Gorgonia: Symbolic differentiation.\nTout d\u0026rsquo;abord, nous allons créer une fonction de coût, puis utiliser un solver pour faire la descente de gradient.\nCreation du \u0026ldquo;node\u0026rdquo; qui contiendra le coût de l\u0026rsquo;équation Completons à présent l\u0026rsquo;exprgraph en ajoutant le coût (pour rappel, $cost = \\dfrac{1}{m} \\sum_{i=1}^m(X^{(i)}\\cdot\\Theta-Y^{(i)})^2$)\nsquaredError := must(gorgonia.Square(must(gorgonia.Sub(pred, y)))) cost := must(gorgonia.Mean(squaredError)) Notre but est de minimiser ce coût. Nous allons donc calculer le gradient de la fonction par rapport à $\\Theta$:\nif _, err := gorgonia.Grad(cost, theta); err != nil { log.Fatalf(\u0026#34;Failed to backpropagate: %v\u0026#34;, err) } La descente du gradient Nous utilisons le principe de descente de gradient. Ceci signifie que nous utilisons le gradient de la fonction pour altérer le paramètre $\\Theta$ pas à pas.\nUne implémentation basique de descente de gradient est implémentée dans le Vanilla Solver de Gorgonia. Nous positionnons le \u0026ldquo;pas\u0026rdquo; $\\gamma$ à 0.001.\nsolver := gorgonia.NewVanillaSolver(gorgonia.WithLearnRate(0.001)) À chaque étape, nous allons demander au solver de mettre à jour $\\Theta$ grâce au gradient. Par conséquent, nous assignons une variable update que nous allons passer au solver à chaque itération.\nLa descente de gradient va mettre à jour toutes les valeurs présentes dans le tableau []gorgonia.ValueGrad à chqaue étape suivant cette équation: ${\\displaystyle x^{(k+1)}=x^{(k)}-\\gamma \\nabla f\\left(x^{(k)}\\right)}$ Il est important de comprendre que le solver travaille sur des Values et non des Nodes. Cependant, afin de simplifier les choses, l\u0026rsquo;interface ValueGrad est implémenté par la structure *Node.\n Dans notre cas, nous voulons trouver les valeurs de $\\Theta$; nous demandons au solver de mettre à jour la valeur en suivant cette équation:\n${\\displaystyle \\Theta^{(k+1)}=\\Theta^{(k)}-\\gamma \\nabla f\\left(\\Theta^{(k)}\\right)}$\nLe solver se charge d\u0026rsquo;implémenter l\u0026rsquo;équation. Nous devons simplement passer $\\Theta$ a chaque Step du Solver:\nupdate := []gorgonia.ValueGrad{theta} // ... if err = solver.Step(update); err != nil { log.Fatal(err) } L\u0026rsquo;apprentissage À présent que la mécanique est en place, nous devons lancer le calcul grâce à une vm. Ce calcul doit être lancé un grand nombre de fois pour que la descente de gradient puisse agir.\nCréons à présent une vm pour lancer le calcul.\nmachine := gorgonia.NewTapeMachine(g, gorgonia.BindDualValues(theta)) defer machine.Close() Nous demandons au \u0026ldquo;solver\u0026rdquo; de mettre à jour le paramètre $\\Theta$ par rapport au gradient. Par conséquent nous devons dire à la TapeMachine de stocker la valeur de $\\Theta$ ainsi que sa dérivée (sa \u0026ldquo;dual value\u0026rdquo;) Ceci est la raison de l\u0026rsquo;utilisation de la fonction BindDualValues.\n Maintenant nous pouvons créer une boucle et calculer le graphe étape par étape; la machine va apprendre!\niter := 1000000 var err error for i := 0; i \u0026lt; iter; i++ { if err = machine.RunAll(); err != nil { fmt.Printf(\u0026#34;Error during iteration: %v: %v\\n\u0026#34;, i, err) break } if err = solver.Step(model); err != nil { log.Fatal(err) } machine.Reset() // Reset is necessary in a loop like this } Afficher des informations Nous pouvons afficher des informations sur le processus d\u0026rsquo;apprentissage en utilisant cet appel:\nfmt.Printf(\u0026#34;theta: %2.2f Iter: %v Cost: %2.3f Accuracy: %2.2f \\r\u0026#34;, theta.Value(), i, cost.Value(), accuracy(predicted.Data().([]float64), y.Value().Data().([]float64))) Avec la fonction accuracy définie de la manière suivante:\nfunc accuracy(prediction, y []float64) float64 { var ok float64 for i := 0; i \u0026lt; len(prediction); i++ { if math.Round(prediction[i]-y[i]) == 0 { ok += 1.0 } } return ok / float64(len(y)) } Ceci affichera une ligne semblable à celle ci pendant la phase d\u0026rsquo;apprentissage:\ntheta: [ 0.26 -0.41 0.44 -0.62 0.83] Iter: 26075 Cost: 0.339 Accuracy: 0.61 Sauvegarde des données Une fois l\u0026rsquo;entraînement terminé, nous pouvons sauvegarder les valeurs de $\\Theta$ pour pouvoir les utiliser dans des prédictions:\nfunc save(value gorgonia.Value) error { f, err := os.Create(\u0026#34;theta.bin\u0026#34;) if err != nil { return err } defer f.Close() enc := gob.NewEncoder(f) err = enc.Encode(value) if err != nil { return err } return nil } Création d\u0026rsquo;un utilitaire en ligne de commande (CLI) Nous allons à présent créer un utilitaire qui va permettre de donner l\u0026rsquo;espèce d\u0026rsquo;une fleur en fonction des paramètres d\u0026rsquo;entrée.\nTout d\u0026rsquo;abord, chargeons les paramètres que nous venons de sauvegarder lors de la phase d\u0026rsquo;entrainement.\nfunc main() { f, err := os.Open(\u0026#34;theta.bin\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() dec := gob.NewDecoder(f) var thetaT *tensor.Dense err = dec.Decode(\u0026amp;thetaT) if err != nil { log.Fatal(err) } Ensuite, créeons le modèle (l\u0026rsquo;exprgraph) d\u0026rsquo;une manière semblable à ce que nous avons fait auparavant:\nDans un développement logiciel, il serait probablement souhaitable de partager ce code entre les deux outils (training et execution) en l\u0026rsquo;isolant dans un package.\n g := gorgonia.NewGraph() theta := gorgonia.NodeFromAny(g, thetaT, gorgonia.WithName(\u0026#34;theta\u0026#34;)) values := make([]float64, 5) xT := tensor.New(tensor.WithBacking(values)) x := gorgonia.NodeFromAny(g, xT, gorgonia.WithName(\u0026#34;x\u0026#34;)) y, err := gorgonia.Mul(x, theta) Ensuite nous executons une boucle infinie pendant laquelle nous allons demander les infos, calculer et afficher le résultat:\nmachine := gorgonia.NewTapeMachine(g) values[4] = 1.0 for { values[0] = getInput(\u0026#34;sepal length\u0026#34;) values[1] = getInput(\u0026#34;sepal widt\u0026#34;) values[2] = getInput(\u0026#34;petal length\u0026#34;) values[3] = getInput(\u0026#34;petal width\u0026#34;) if err = machine.RunAll(); err != nil { log.Fatal(err) } switch math.Round(y.Value().Data().(float64)) { case 1: fmt.Println(\u0026#34;It is probably a setosa\u0026#34;) case 2: fmt.Println(\u0026#34;It is probably a virginica\u0026#34;) case 3: fmt.Println(\u0026#34;It is probably a versicolor\u0026#34;) default: fmt.Println(\u0026#34;unknown iris\u0026#34;) } machine.Reset() } Voici une fonction utilitaire pour récupérer les entrées:\nfunc getInput(s string) float64 { reader := bufio.NewReader(os.Stdin) fmt.Printf(\u0026#34;%v: \u0026#34;, s) text, _ := reader.ReadString(\u0026#39;\\n\u0026#39;) text = strings.Replace(text, \u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;, -1) input, err := strconv.ParseFloat(text, 64) if err != nil { log.Fatal(err) } return input } Il ne reste plus qu\u0026rsquo;à \u0026ldquo;builder\u0026rdquo; le code et voilà! Nous avons un utilitaire autonome capable de prédire l\u0026rsquo;espèce d\u0026rsquo;une Irir en fonction de ses attributs:\n$ go run main.go sepal length: 4.4 sepal widt: 2.9 petal length: 1.4 petal width: 0.2 It is probably a setosa sepal length: 5.9 sepal widt: 3.0 petal length: 5.1 petal width: 1.8 It is probably a virginica Conclusion Dans cet exemple pas-à-pas, nous avons construit un logiciel complet.\nÀ présent vous pouvez poursuivre les tests en changeant les valeurs initiales de $\\Theta$ ou en utilisant un autre solver fournit par Gorgonia.\nLe code complet de ce tutoriel est présent dans le répertoire examples des sources de Gorgonia.\nBonus: representation visuelle Il est possible de visualiser le dataset en utilisant la bibliothèque plotter du projet Gonum. Voici un exemple.\nimport ( \u0026#34;gonum.org/v1/plot\u0026#34; \u0026#34;gonum.org/v1/plot/plotter\u0026#34; \u0026#34;gonum.org/v1/plot/plotutil\u0026#34; \u0026#34;gonum.org/v1/plot/vg\u0026#34; \u0026#34;gonum.org/v1/plot/vg/draw\u0026#34; ) func plotData(x []float64, a []float64) []byte { p, err := plot.New() if err != nil { log.Fatal(err) } p.Title.Text = \u0026#34;sepal length \u0026amp; width\u0026#34; p.X.Label.Text = \u0026#34;length\u0026#34; p.Y.Label.Text = \u0026#34;width\u0026#34; p.Add(plotter.NewGrid()) l := len(x) / len(a) for k := 1; k \u0026lt;= 3; k++ { data0 := make(plotter.XYs, 0) for i := 0; i \u0026lt; len(a); i++ { if k != int(a[i]) { continue } x1 := x[i*l+0] // sepal_length \ty1 := x[i*l+1] // sepal_width \tdata0 = append(data0, plotter.XY{X: x1, Y: y1}) } data, err := plotter.NewScatter(data0) if err != nil { log.Fatal(err) } data.GlyphStyle.Color = plotutil.Color(k - 1) data.Shape = \u0026amp;draw.PyramidGlyph{} p.Add(data) p.Legend.Add(fmt.Sprint(k), data) } w, err := p.WriterTo(4*vg.Inch, 4*vg.Inch, \u0026#34;png\u0026#34;) if err != nil { panic(err) } var b bytes.Buffer writer := bufio.NewWriter(\u0026amp;b) w.WriteTo(writer) ioutil.WriteFile(\u0026#34;out.png\u0026#34;, b.Bytes(), 0644) return b.Bytes() }"},{"uri":"https://gorgonia.org/fr/how-to/dataframe/","title":"Créer un tensor depuis un Dataframe (gota)","tags":[],"description":"","content":" Cet article explique comment créer un tenseur depuis un dataframe en utilisant le package gota.\nLe but est de lire un fichier csv et de créer un objet *tensor.Dense de forme (2,2).\nCreation du dataframe depuis le fichier csv Considerons un ficier csv avec le contenu suivant:\nsepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... Ceci est un extrait du Iris flower data set. Une copie du dataset peut être téléchargée ici\n Nous voulons créer un tenseur qui contient toutes les valeurs sauf la colonne \u0026ldquo;species\u0026rdquo;.\nCreation du dataframe avec gota le package dataframe de gota propose une fonction ReadCSV qui prend pour argument un io.Reader.\nf, err := os.Open(\u0026#34;iris.csv\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() df := dataframe.ReadCSV(f) df est un DataFrame qui remferme toutes les données présentes dans le fichier.\ngota utilise la première ligne du fichier csv pour référencer les colonnes dans le dataframe\n Supprimons à présent la colonne species du dataframe:\nxDF := df.Drop(\u0026#34;species\u0026#34;) Conversion du dataframe vers une matrice Pour simplifier les choses, nous allons convertir le dataframe en une Matrix telle que définie dans le package gonum (cf la godoc de Matrix). Matrix est une interface. Cependant, la structure Dataframe de gota ne remplit pas le contrat d\u0026rsquo;interface Matrix Nous allons donc encapsuler l\u0026rsquo;objet dans une structure de plus haut niveau et nous allons implémenter les fonctions nécessaire au contrat d\u0026rsquo;interface telle que décrit dans la documentation de gota:\ntype matrix struct { dataframe.DataFrame } func (m matrix) At(i, j int) float64 { return m.Elem(i, j).Float() } func (m matrix) T() mat.Matrix { return mat.Transpose{Matrix: m} } Creation du tenseur Nous pouvons à présent créer un tenseur *Dense grâce à la fonction tensor.FromMat64 du package tensor en encapsulant le dataframe dans la structure matrix.\nxT := tensor.FromMat64(mat.DenseCopyOf(\u0026amp;matrix{xDF}))"},{"uri":"https://gorgonia.org/fr/how-to/","title":"How-tos","tags":[],"description":"","content":""},{"uri":"https://gorgonia.org/fr/","title":"Gorgonia","tags":[],"description":"","content":" Gorgonia Gorgonia est une bibliothèque qui facilite la mise en place de mécanismes de machine learning en Go.\nElle permet d\u0026rsquo;écrire et de calculer des équations mathématiques utilisant des tableaux à multiples dimensions.\nDans l\u0026rsquo;idée, cette bibliothèque est semblable à Theano et TensorFlow.\nD\u0026rsquo;une manière générale, cette bibliothèque est relativement bas-niveau, comme Theano, mais possède des objectifs plus ambitieux comme TensorFlow.\nPourquoi utiliser Gorgonia ? La cible principale de Gorgonia est de rendre l\u0026rsquo;expérience du développeur agréable. So vous êtes un Gopher, grâce à Gorgonia, vous avez la possibilité de créer des systèmes utilisant le machine learning qui soient \u0026ldquo;production-ready\u0026rdquo;.\nLe développement en IA/ML est généralement divisé en deux étapes:\n Les expériences pendant lesquels sont conçus les modèles, et pendant lesquels beaucoup de tests sont réalisés. La phase de déploiement pendant laquelle les modèles sont industrialisés pour être opérés à l\u0026rsquo;échelle.  Ces différentes phases sont associées à divers métiers tels que data-scientiste ou data-ingénieur.\nD\u0026rsquo;une manière générale, ces deux étapes ne sont pas réalisées en utilisant les mêmes outils:\n Python/Lua (et les frameworks de type Theano, Torch, etc), sont couramment utilisés dans les phases d\u0026rsquo;expérimentation. Durant les phases d\u0026rsquo;exploitation et de déploiement, le modèle est en général réécrit dans un langage plus performant tel que le C++. (en utilisant par exemple dlib, mlpack etc).  Bien entendu, de nos jours, l\u0026rsquo;écart de performance entre les outils se réduit, ce qui aboutit à un partage des outils entre les différentes phases. TensorFlow est un exemple d\u0026rsquo;outil qui est utilisé dans les deux étapes du développement et qui opère comme un pont entre deux.\nLe but de Gorgonia est le même, mais dans l\u0026rsquo;écosystème Go. Gorgonia est performant. Sa vitesse d\u0026rsquo;exécution sur CPU est comparable à Theano et TensorFlow. Les implémentations GPU sont plus délicates à comparer dû à la charge induite par l\u0026rsquo;utilisation de CGO. Cette partie est en développement actif.\nOrganisation de ce site web Ce site web est composé de 4 sections ayant différents objectifs:\n Premiers pas  Démarrer rapidement avec Gorgonia\n Fonctionnement de Gorgonia  Suite d\u0026#39;articles pour expliquer le fonctionnement de Gorgonia\n Tutoriels  Tutoriels sur quelques cas d\u0026#39;usage\n How-tos  \n "},{"uri":"https://gorgonia.org/fr/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://gorgonia.org/fr/tags/","title":"Tags","tags":[],"description":"","content":""}]